$Id$

This is a description of the server-side classes and the way they
interact.

Zone:  This is the main overlying object which encompasses an entire
server.  Its purpose is to keep track of: 1) the geometry of the
section of the world that the server encompasses, 2) the complete list
of actions which may be performed in that world section, 3) the
complete list of inhabitants of the world section, and 4) the basic
behaviour of the world section (gravity, weather, etc).  The zone also
has record of which zones are adjacent to it in each direction, so it
can inform players when they are reaching the edges of the server's
responsibility.  It may maintain a complete map geometry even after
all the sectors have been created (and geometry added to each sector).
One goal is to have dynamically-allocated sectors in the case of empty
space; when something enters the space, the sector is created, and
when all objects exit a sector, it is deleted.  The memory savings
may become important on some systems (such as a space genre, where
there are vast expanses of completely empty space).

Sector (currently unused):  This is the basic subdivision of space.  A
zone is represented as a 3-dimensional grid of sectors, possibly a
sparsely populated grid.  Each sector contains an octree, which
contains all the elements of that sector.  The octree maintains a list
of the polys which it contains, and each leaf octant contains pointers
to elements of the poly list.  Each octant also has pointers to each
of its neighbors, for simpler traversal.  It might be even more
efficient to maintain a zone- wide list of polys, and have each
sector's octree point to elements in this master list, instead of
having possibly duplicate data floating around.

Game Object:  This is the basic dynamic object.  Everything which *can*
move around in the world is represented as such an object.  The game
object contains references to default control objects and geometries,
as well as current control objects and geometries, which may be
changed at any time.  Removing the control or geometry will cause the
object to revert to its default.  Each object also contains an object
ID value, currently represented as a 64-bit integer.  The game object
also knows about attributes, natures, and actions that it has/can use.
Each game object has a two-stage bounding volume; the first stage is a
simple sphere, and the second stage is a tight box or set of boxes.

Control:  This object keeps track of a logged-in player, and the game
object to which s/he is associated.  The control object will be the
basic method for accessing a given character's object, and also be a
dispatcher for taking action requests from the user and (possibly)
turning them into game activity.

Action routine:  These will not be classes per se, but more probably
either templatized routines, or just a set of routines with an
enforced signature.  They will be responsible for checking if the
source game object can either perform the action or some other default
action, and doing the actual action.  The action routines are the only
part of this API which can actually create command objects and/or game
objects.  For example, a fireball would necessitate creation of the
fireball itself, and a control object to make it move and explode on
contact with something (or fizzle out after a time, or what have you).
These functions will require a source object (objectid), a destination
object, an operation vector (i.e. the direction), and a power level.

Some ancillary support types

Octree (currently unused):  General space representation of each sector.

Nature (currently unused):  An integer (possibly just a boolean value)
representing some fundamental state of the game object, such as "wet"
or "cold".

Attribute:  An integer representing the game object's power level in
a given attribute.  Attributes are basic physical parameters that
the object has, such as strength, stamina, agility, etc.

ActionLevel:  An integer representation of a game object's skill level.
